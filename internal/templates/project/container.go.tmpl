package main

import (
	"context"
	"fmt"
	"os"

	"{{ .GoModule }}/pkg/config"
	"{{ .GoModule }}/pkg/logx"
{{- if .HasFSX }}
	"{{ .GoModule }}/pkg/fsx"
	"{{ .GoModule }}/pkg/fsx/fsxlocal"
	"{{ .GoModule }}/pkg/fsx/fsxs3"
{{- end }}
{{- if .HasIAM }}
	"{{ .GoModule }}/pkg/iam"
	"{{ .GoModule }}/pkg/iam/apikey"
	"{{ .GoModule }}/pkg/iam/apikey/apikeyapi"
	"{{ .GoModule }}/pkg/iam/apikey/apikeyinfra"
	"{{ .GoModule }}/pkg/iam/apikey/apikeysrv"
	"{{ .GoModule }}/pkg/iam/auth"
	"{{ .GoModule }}/pkg/iam/auth/authinfra"
	"{{ .GoModule }}/pkg/iam/invitation/invitationapi"
	"{{ .GoModule }}/pkg/iam/invitation/invitationinfra"
	"{{ .GoModule }}/pkg/iam/invitation/invitationsrv"
	"{{ .GoModule }}/pkg/iam/otp/otpinfra"
	"{{ .GoModule }}/pkg/iam/otp/otpsrv"
	"{{ .GoModule }}/pkg/iam/tenant/tenantinfra"
	"{{ .GoModule }}/pkg/iam/tenant/tenantsrv"
	"{{ .GoModule }}/pkg/iam/user/userinfra"
	"{{ .GoModule }}/pkg/iam/user/usersrv"
{{- end }}
{{- if .HasFSX }}
	awsConfig "github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/s3"
{{- end }}
	"github.com/jmoiron/sqlx"
	_ "github.com/lib/pq"
{{- if .HasIAM }}
	"github.com/redis/go-redis/v9"
{{- end }}
)

// Container holds all application dependencies
type Container struct {
	// Config
	Config *config.Config

	// Infrastructure
	DB *sqlx.DB
{{- if .HasIAM }}
	Redis *redis.Client
{{- end }}
{{- if .HasFSX }}
	FileSystem fsx.FileSystem
	S3Client   *s3.Client
{{- end }}
{{- if .HasIAM }}

	// Core IAM Services
	OAuthHandlers        *auth.AuthHandlers
	PasswordlessHandlers *auth.PasswordlessAuthHandlers
	TokenService         auth.TokenService
	APIKeyService        *apikeysrv.APIKeyService
	TenantService        *tenantsrv.TenantService
	UserService          *usersrv.UserService
	InvitationService    *invitationsrv.InvitationService
	OTPService           *otpsrv.OTPService

	// API Handlers
	APIKeyHandlers     *apikeyapi.APIKeyHandlers
	InvitationHandlers *invitationapi.InvitationHandlers

	// Middleware
	UnifiedAuthMiddleware *auth.UnifiedAuthMiddleware
	AuthMiddleware        *auth.TokenMiddleware

	// Background Services
	CleanupService *authinfra.CleanupService
{{- end }}
}

// NewContainer initializes the dependency injection container
func NewContainer(cfg *config.Config) *Container {
	logx.Info("üîß Initializing dependency container...")

	c := &Container{
		Config: cfg,
	}

	c.initInfrastructure()
{{- if .HasIAM }}
	c.initRepositories()
{{- end }}

	logx.Info("‚úÖ Container initialized successfully")
	return c
}

func (c *Container) initInfrastructure() {
	logx.Info("üèóÔ∏è Initializing infrastructure...")

	// Database
	dsn := fmt.Sprintf("host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
		c.Config.Database.Host,
		c.Config.Database.Port,
		c.Config.Database.User,
		c.Config.Database.Password,
		c.Config.Database.Name,
		c.Config.Database.SSLMode,
	)

	db, err := sqlx.Connect("postgres", dsn)
	if err != nil {
		logx.Fatalf("Failed to connect to database: %v", err)
	}
	db.SetMaxOpenConns(c.Config.Database.MaxOpenConns)
	db.SetMaxIdleConns(c.Config.Database.MaxIdleConns)
	db.SetConnMaxLifetime(c.Config.Database.ConnMaxLifetime)
	c.DB = db
	logx.Info("‚úÖ Database connected")

{{- if .HasIAM }}

	// Redis
	c.Redis = redis.NewClient(&redis.Options{
		Addr:     c.Config.Redis.Address(),
		Password: c.Config.Redis.Password,
		DB:       c.Config.Redis.DB,
	})
	if _, err := c.Redis.Ping(context.Background()).Result(); err != nil {
		logx.Fatalf("Failed to connect to Redis: %v (Redis is required)", err)
	} else {
		logx.Info("‚úÖ Redis connected")
	}
{{- end }}

{{- if .HasFSX }}

	// File Storage
	c.initFileStorage()
{{- end }}

	logx.Info("‚úÖ Infrastructure initialized")
}

{{- if .HasFSX }}

func (c *Container) initFileStorage() {
	storageMode := getEnv("STORAGE_MODE", "local")

	switch storageMode {
	case "s3":
		awsRegion := getEnv("AWS_REGION", "us-east-1")
		awsBucket := getEnv("AWS_BUCKET", "{{ .ProjectName }}-uploads")

		cfg, err := awsConfig.LoadDefaultConfig(context.TODO(), awsConfig.WithRegion(awsRegion))
		if err != nil {
			logx.Fatalf("Unable to load AWS SDK config: %v", err)
		}
		c.S3Client = s3.NewFromConfig(cfg)
		c.FileSystem = fsxs3.NewS3FileSystem(c.S3Client, awsBucket, "")
		logx.Infof("‚úÖ S3 file system configured (bucket: %s, region: %s)", awsBucket, awsRegion)

	case "local":
		uploadDir := getEnv("UPLOAD_DIR", "./uploads")
		localFS, err := fsxlocal.NewLocalFileSystem(uploadDir)
		if err != nil {
			logx.Fatalf("Failed to initialize local file system: %v", err)
		}
		c.FileSystem = localFS
		logx.Infof("‚úÖ Local file system configured (path: %s)", localFS.GetBasePath())

	default:
		logx.Fatalf("Unknown STORAGE_MODE: %s (use 'local' or 's3')", storageMode)
	}
}
{{- end }}

{{- if .HasIAM }}

func (c *Container) initRepositories() {
	logx.Info("üóÑÔ∏è  Initializing repositories and services...")

	// --- IAM Repositories ---
	tenantRepo := tenantinfra.NewPostgresTenantRepository(c.DB)
	tenantConfigRepo := tenantinfra.NewPostgresTenantConfigRepository(c.DB)
	userRepo := userinfra.NewPostgresUserRepository(c.DB)
	tokenRepo := authinfra.NewPostgresTokenRepository(c.DB)
	sessionRepo := authinfra.NewPostgresSessionRepository(c.DB)
	passwordResetRepo := authinfra.NewPostgresPasswordResetRepository(c.DB)
	invitationRepo := invitationinfra.NewPostgresInvitationRepository(c.DB)
	apiKeyRepo := apikeyinfra.NewPostgresAPIKeyRepository(c.DB)
	otpRepo := otpinfra.NewPostgresOTPRepository(c.DB)

	// --- Infrastructure Services ---

	// State Manager
	var stateManager auth.StateManager
	if c.Config.OAuth.StateManager.Type == "redis" {
		stateManager = authinfra.NewRedisStateManager(c.Redis, c.Config.OAuth.StateManager.TTL)
		logx.Info("‚úÖ Using Redis state manager for OAuth")
	} else {
		stateManager = auth.NewInMemoryStateManager(c.Config.OAuth.StateManager.TTL)
		logx.Warn("‚ö†Ô∏è  Using in-memory state manager (not recommended for production)")
	}

	// Password Service
	passwordSvc := authinfra.NewBcryptPasswordService(c.Config.Auth.Password.BcryptCost)

	// Token Service
	c.TokenService = auth.NewJWTServiceFromConfig(&c.Config.Auth.JWT)

	// API Key Configuration
	apikey.InitAPIKeyConfig(
		c.Config.Auth.APIKey.LivePrefix,
		c.Config.Auth.APIKey.TestPrefix,
		c.Config.Auth.APIKey.TokenLength,
	)

	// --- IAM Domain Services ---
	c.TenantService = tenantsrv.NewTenantService(
		tenantRepo,
		tenantConfigRepo,
		userRepo,
		&c.Config.TenantConfig,
	)

	c.UserService = usersrv.NewUserService(
		userRepo,
		tenantRepo,
		passwordSvc,
	)

	c.InvitationService = invitationsrv.NewInvitationService(
		invitationRepo,
		userRepo,
		tenantRepo,
		&c.Config.Auth.Invitation,
	)

	c.APIKeyService = apikeysrv.NewAPIKeyService(
		apiKeyRepo,
		tenantRepo,
		userRepo,
	)

	// OTP Service with Console Notifier (development)
	// TODO: Replace with real email/SMS service in production
	c.OTPService = otpsrv.NewOTPService(
		otpRepo,
		NewConsoleNotifier(),
		&c.Config.Auth.OTP,
	)

	// --- OAuth Services ---
	oauthServices := make(map[iam.OAuthProvider]auth.OAuthService)

	if c.Config.OAuth.Google.Enabled {
		oauthServices[iam.OAuthProviderGoogle] = auth.NewGoogleOAuthServiceFromConfig(
			&c.Config.OAuth.Google,
			stateManager,
		)
		logx.Info("‚úÖ Google OAuth enabled")
	}

	if c.Config.OAuth.Microsoft.Enabled {
		oauthServices[iam.OAuthProviderMicrosoft] = auth.NewMicrosoftOAuthServiceFromConfig(
			&c.Config.OAuth.Microsoft,
			stateManager,
		)
		logx.Info("‚úÖ Microsoft OAuth enabled")
	}

	// --- Authentication Handlers ---
	c.OAuthHandlers = auth.NewAuthHandlers(
		oauthServices,
		c.TokenService,
		userRepo,
		tenantRepo,
		tokenRepo,
		sessionRepo,
		stateManager,
		invitationRepo,
		c.Config,
	)
	logx.Info("‚úÖ OAuth handlers initialized")

	c.PasswordlessHandlers = auth.NewPasswordlessAuthHandlers(
		c.TokenService,
		userRepo,
		tenantRepo,
		tokenRepo,
		sessionRepo,
		invitationRepo,
		c.OTPService,
		c.Config,
	)
	logx.Info("‚úÖ Passwordless handlers initialized")

	// --- API Handlers ---
	c.APIKeyHandlers = apikeyapi.NewAPIKeyHandlers(c.APIKeyService)
	c.InvitationHandlers = invitationapi.NewInvitationHandlers(c.InvitationService)

	// --- Middleware ---
	c.AuthMiddleware = auth.NewAuthMiddleware(c.TokenService)
	c.UnifiedAuthMiddleware = auth.NewAPIKeyMiddleware(c.APIKeyService, c.TokenService)

	// --- Background Services ---
	c.CleanupService = authinfra.NewCleanupService(
		tokenRepo,
		sessionRepo,
		passwordResetRepo,
		c.Config.Auth.Session.CleanupInterval,
	)

	logx.Info("‚úÖ All services and handlers initialized")
}

// StartBackgroundServices starts background workers
func (c *Container) StartBackgroundServices(ctx context.Context) {
	logx.Info("üîÑ Starting background services...")
	go c.CleanupService.Start(ctx)
	logx.Info("‚úÖ Cleanup service started")
}
{{- end }}

// Cleanup closes all connections and stops workers
func (c *Container) Cleanup() {
	logx.Info("üßπ Cleaning up resources...")

	if c.DB != nil {
		if err := c.DB.Close(); err != nil {
			logx.Errorf("Error closing database: %v", err)
		} else {
			logx.Info("‚úÖ Database connection closed")
		}
	}

{{- if .HasIAM }}

	if c.Redis != nil {
		if err := c.Redis.Close(); err != nil {
			logx.Errorf("Error closing Redis: %v", err)
		} else {
			logx.Info("‚úÖ Redis connection closed")
		}
	}
{{- end }}

	logx.Info("‚úÖ Cleanup completed")
}

// ============================================================================
// Helpers
// ============================================================================

func getEnv(key, defaultValue string) string {
	if value := os.Getenv(key); value != "" {
		return value
	}
	return defaultValue
}

{{- if .HasIAM }}

// ConsoleNotifier implements OTP notification via console (dev only)
type ConsoleNotifier struct{}

func NewConsoleNotifier() *ConsoleNotifier { return &ConsoleNotifier{} }

func (n *ConsoleNotifier) SendOTP(ctx context.Context, contact string, code string) error {
	fmt.Println()
	fmt.Println(repeatStr("=", 60))
	fmt.Println("üìß OTP NOTIFICATION (Console Output)")
	fmt.Println(repeatStr("=", 60))
	fmt.Printf("üì® To: %s\n", contact)
	fmt.Printf("üîê Code: %s\n", code)
	fmt.Println(repeatStr("=", 60))
	fmt.Println("‚ö†Ô∏è  This is console output for development only")
	fmt.Println(repeatStr("=", 60))
	fmt.Println()

	logx.Infof("üìß OTP sent to %s: %s", contact, code)
	return nil
}

func repeatStr(s string, count int) string {
	result := ""
	for range count {
		result += s
	}
	return result
}
{{- end }}
