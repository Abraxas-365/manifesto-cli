package {{ .PackageName }}infra

import (
	"context"
	"database/sql"
	"errors"

	"{{ .GoModule }}/{{ .DomainPath }}"
	"{{ .GoModule }}/pkg/errx"
	"{{ .GoModule }}/pkg/kernel"
	"github.com/jmoiron/sqlx"
	"github.com/lib/pq"
)

type Postgres{{ .EntityName }}Repository struct {
	db *sqlx.DB
}

func NewPostgres{{ .EntityName }}Repository(db *sqlx.DB) {{ .PackageName }}.Repository {
	return &Postgres{{ .EntityName }}Repository{db: db}
}

func (r *Postgres{{ .EntityName }}Repository) Create(ctx context.Context, entity *{{ .PackageName }}.{{ .EntityName }}) error {
	query := `INSERT INTO {{ .TableName }} (id, tenant_id, created_at, updated_at)
	          VALUES ($1, $2, $3, $4)`
	_, err := r.db.ExecContext(ctx, query, entity.ID, entity.TenantID, entity.CreatedAt, entity.UpdatedAt)
	if err != nil {
		var pqErr *pq.Error
		if errors.As(err, &pqErr) && pqErr.Code == "23505" {
			return {{ .PackageName }}.Err{{ .EntityName }}AlreadyExists()
		}
		return errx.Wrap(err, "create {{ .PackageName }}", errx.TypeInternal)
	}
	return nil
}

func (r *Postgres{{ .EntityName }}Repository) Update(ctx context.Context, entity *{{ .PackageName }}.{{ .EntityName }}) error {
	query := `UPDATE {{ .TableName }} SET updated_at = $1 WHERE id = $2`
	result, err := r.db.ExecContext(ctx, query, entity.UpdatedAt, entity.ID)
	if err != nil {
		return errx.Wrap(err, "update {{ .PackageName }}", errx.TypeInternal)
	}
	rows, _ := result.RowsAffected()
	if rows == 0 {
		return {{ .PackageName }}.Err{{ .EntityName }}NotFound()
	}
	return nil
}

func (r *Postgres{{ .EntityName }}Repository) GetByID(ctx context.Context, id kernel.{{ .EntityName }}ID) (*{{ .PackageName }}.{{ .EntityName }}, error) {
	var entity {{ .PackageName }}.{{ .EntityName }}
	query := `SELECT * FROM {{ .TableName }} WHERE id = $1`
	if err := r.db.QueryRowxContext(ctx, query, id).StructScan(&entity); err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, {{ .PackageName }}.Err{{ .EntityName }}NotFound()
		}
		return nil, errx.Wrap(err, "get {{ .PackageName }}", errx.TypeInternal)
	}
	return &entity, nil
}

func (r *Postgres{{ .EntityName }}Repository) List(ctx context.Context, tenantID kernel.TenantID, opts kernel.PaginationOptions) (kernel.Paginated[{{ .PackageName }}.{{ .EntityName }}], error) {
	var total int
	if err := r.db.QueryRowxContext(ctx, `SELECT COUNT(*) FROM {{ .TableName }} WHERE tenant_id = $1`, tenantID).Scan(&total); err != nil {
		return kernel.Paginated[{{ .PackageName }}.{{ .EntityName }}]{}, errx.Wrap(err, "list {{ .PackageName }}", errx.TypeInternal)
	}

	offset := (opts.Page - 1) * opts.PageSize
	var items []{{ .PackageName }}.{{ .EntityName }}
	if err := r.db.SelectContext(ctx, &items,
		`SELECT * FROM {{ .TableName }} WHERE tenant_id = $1 ORDER BY created_at DESC LIMIT $2 OFFSET $3`,
		tenantID, opts.PageSize, offset); err != nil {
		return kernel.Paginated[{{ .PackageName }}.{{ .EntityName }}]{}, errx.Wrap(err, "list {{ .PackageName }}", errx.TypeInternal)
	}

	return kernel.NewPaginated(items, opts.Page, opts.PageSize, total), nil
}

func (r *Postgres{{ .EntityName }}Repository) Delete(ctx context.Context, id kernel.{{ .EntityName }}ID) error {
	result, err := r.db.ExecContext(ctx, `DELETE FROM {{ .TableName }} WHERE id = $1`, id)
	if err != nil {
		return errx.Wrap(err, "delete {{ .PackageName }}", errx.TypeInternal)
	}
	rows, _ := result.RowsAffected()
	if rows == 0 {
		return {{ .PackageName }}.Err{{ .EntityName }}NotFound()
	}
	return nil
}
